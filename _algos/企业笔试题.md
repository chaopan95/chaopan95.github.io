---
layout: page
title:  "企业笔试题"
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


{:toc}

* 
{:toc}



<style>
table {
  border-collapse: collapse;
  border: 1px solid black;
  margin: 0 auto;
} 

th,td {
  border: 1px solid black;
  text-align: center;
  padding: 20px;
}

table.a {
  table-layout: auto;
  width: 180px;  
}

table.b {
  table-layout: fixed;
  width: 600px;  
}

table.c {
  table-layout: auto;
  width: 100%;  
}

table.d {
  table-layout: fixed;
  width: 100%;  
}
</style>


## 拼多多
### 多多的魔术盒子
<p align="justify">
多多鸡有N个魔术盒子（编号1～N），其中编号为i的盒子里有i个球。<br>
多多鸡让皮皮虾每次选择一个数字X（1 <= X <= N），多多鸡就会把球数量大于等于X个的盒子里的球减少X个。<br>
通过观察，皮皮虾已经掌握了其中的奥秘，并且发现只要通过一定的操作顺序，可以用最少的次数将所有盒子里的球变没。<br>
那么请问聪明的你，是否已经知道了应该如何操作呢？<br><br>

<b>输入描述:</b><br>
第一行，有1个整数T，表示测试用例的组数。<br>
（1 <= T <= 100）<br>
接下来T行，每行1个整数N，表示有N个魔术盒子。<br>
（1 <= N <= 1,000,000,000）<br><br>

<b>输出描述:</b><br>
共T行，每行1个整数，表示要将所有盒子的球变没，最少需要进行多少次操作。<br><br>

<b>示例:</b><br>
输入<br>
3<br>
1<br>
2<br>
5<br>
输出<br>
1<br>
2<br>
3<br><br>

<b>Solution:</b>
$$
f(x) = 
\begin{cases}
1, &\quad x = 1 \\
1 + f(x - \left \lfloor \frac{1 + x}{2} \right \rfloor), &\quad x > 1
\end{cases}
$$
</p>
{% highlight C++ %}
#include<iostream>
using namespace std;

int getReduceTimes(int n)
{
    if (n == 1) { return 1; }
    else { return 1 + getReduceTimes(n-(1+n)/2); }
}

int main(int argc, const char * argv[])
{
    int T = 3, n = 1;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &n);
        printf("%d\n", getReduceTimes(n));
    }
    return 0;
}
{% endhighlight %}

### 多多的排列函数
<p align="justify">
数列 {An} 为N的一种排列。例如N=3，可能的排列共6种：<br>
1, 2, 3<br>
1, 3, 2<br>
2, 1, 3<br>
2, 3, 1<br>
3, 1, 2<br>
3, 2, 1<br>
定义函数F:
$$
F(x) =
\begin{cases}
A_{1},  &\quad x = 1\\
\left | F(x-1) - A_{x} \right |, &\quad x > 1
\end{cases}
$$
其中|X|表示X的绝对值。现在多多鸡想知道，在所有可能的数列 {An} 中，F(N)的最小值和最大值分别是多少。<br><br>

<b>输入描述:</b><br>
第一行输入1个整数T，表示测试用例的组数。<br>
( 1 <= T <= 10 )<br>
第二行开始，共T行，每行包含1个整数N，表示数列 {An} 的元素个数。<br>
( 1 <= N <= 100,000 )<br><br>

<b>输出描述:</b><br>
共T行，每行2个整数，分别表示F(N)最小值和最大值<br><br>

<b>示例:</b><br>
输入<br>
2<br>
2<br>
3<br>
输出<br>
1 1<br>
0 2<br>
说明<br>
对于N=3：<br>
- 当{An}为3，2，1时可以得到F(N)的最小值0<br>
- 当{An}为2，1，3时可以得到F(N)的最大值2<br><br>

<b>备注:</b><br>
对于60%的数据有： 1 <= N <= 100<br>
对于100%的数据有：1 <= N <= 100,000<br><br>

<b>Solution:</b><br>
1.最小值看n%4的余数，余数为1或2时，取值为1，其他为0；<br>
2.最大值相当于在1,2,...,n-1数列的一种最小值排列的右边再放一个n，所以最大值取值为Fmin-n；
</p>
{% highlight C++ %}
#include<iostream>
using namespace std;

int getMin(int n)
{
    if (n % 4 == 1 || n % 4 == 2) { return 1; }
    else { return 0; }
}

int getMax(int n)
{
    return n - getMin(n-1);
}

int main(int argc, const char * argv[])
{
    int T = 2, i = 1;
    scanf("%d", &T);
    while (T--)
    {
        scanf("%d", &i);
        printf("%d %d\n", getMin(i), getMax(i));
    }
    return 0;
}
{% endhighlight %}

### 多多的电子字典
<p align="justify">
多多鸡打算造一本自己的电子字典，里面的所有单词都只由a和b组成。每个单词的组成里a的数量不能超过N个且b的数量不能超过M个。多多鸡的幸运数字是K，它打算把所有满足条件的单词里的字典序第K小的单词找出来，作为字典的封面。<br><br>

<b>输入描述:</b><br>
共一行，三个整数N, M, K。(0 < N, M < 50, 0 < K < 1,000,000,000,000,000)<br><br>

<b>输出描述:</b><br>
共一行，为字典序第K小的单词。<br><br>

<b>示例:</b><br>
输入<br>
2 1 4<br>
输出<br>
ab<br>
说明<br>
满足条件的单词里，按照字典序从小到大排列的结果是<br>
a<br>
aa<br>
aab<br>
ab<br>
aba<br>
b<br>
ba<br>
baa<br><br>

<b>备注:</b><br>
对于40%的数据：0 < K < 100,000<br>
对于100%的数据：0 < K < 1,000,000,000,000,000<br>
题目保证第K小的单词一定存在<br><br>

<b>Solution:</b><br>
本题相当于有两个树，以a开头和以b开头的两颗二叉树。 每一次的count是返回以当前节点"a"或者"b"开头的前序遍历需要经过的步数，这里说一下动态规划的递推公式：dp[i][j] = dp[i-1][j] + 1 + dp[i][j-1] + 1 什么意思呢？ 就是返回以"a"开头的和以"b"开头的个数。比如a[2][1] = dp[1][1] + dp[2][0] + 2 dp[1][1] + 1是以"a"开头的个数，即我们可以固定一个"a"在开头。这样就少了一个a可以用，那么只剩下了[a,b]可以组合 即：a,ab,ba,b; 然后再和固定的a开头的字母"a"组合，即aa,aab,aba,ab，这个时候组合就相当于是dp[1][1]。以a开头的组合显然少了一个"a"这个特殊的组合，显然dp[1][1] + 1才是以"a"开头的组合个数。
</p>
{% highlight C++ %}
#include<iostream>
#include<string>
using namespace std;

string dict(int n, int m, long k)
{
    string res = "a";
    int len = 1;
    unsigned long long **dp = new unsigned long long *[n+1];
    for (int i = 0; i <= n; i++)
    {
        dp[i] = new unsigned long long [m+1]{};
        dp[i][0] = i;
    }
    for (int j = 0; j <= m; j++) { dp[0][j] = j; }
    
    for (int i = 1; i <= n; i++)
    {
        for (int j = 1; j <= m; j++)
        {
            dp[i][j] = dp[i-1][j] + dp[i][j-1] + 2;
        }
    }
    
    n--;
    k--;
    while (k > 0 && (n > 0 || m > 0))
    {
        unsigned long long count = dp[n][m] + 1;
        if (count <= k)
        {
            k -= count;
            n++;
            m--;
            res[len-1] = 'b';
        }
        else
        {
            k--;
            if (n > 0)
            {
                res.push_back('a');
                n--;
            }
            else
            {
                res.push_back('b');
                m--;
            }
            len++;
        }
    }
    for (int i = 0; i <= n; i++) { delete []dp[i]; }
    delete []dp;
    return res;
}

int main(int argc, const char *argv[])
{
    int n = 2, m = 1;
    long k = 4;
    scanf("%d%d%ld", &n, &m, &k);
    printf("%s\n", dict(n, m, k).c_str());
    return 0;
}
{% endhighlight %}

### 骰子期望
<p align="justify">
扔n个骰子，第i个骰子有可能投掷出Xi种等概率的不同的结果，数字从1到Xi。所有骰子的结果的最大值将作为最终结果。求最终结果的期望。<br><br>

<b>输入描述:</b><br>
第一行一个整数n，表示有n个骰子。（1 <= n <= 50）<br>
第二行n个整数，表示每个骰子的结果数Xi。(2 <= Xi <= 50)<br><br>

<b>输出描述:</b><br>
输出最终结果的期望，保留两位小数。<br><br>

<b>示例:</b><br>
输入<br>
2<br>
2 2<br>
输出<br>
1.75<br><br>

<b>Solution:</b>
$$P(x = A) = P(x \leq A) - P(x \leq (A-1))$$
</p>
{% highlight C++ %}
#include<iostream>
using namespace std;

double calProb(int *arr, int n, int MAX)
{
    double res = 0.0, pre = 0.0, cur = 0.0;
    for (int i = 1; i <= MAX; i++)
    {
        cur = 1.0;
        for (int j = 0; j < n; j++)
        {
            cur *= double(min(i, arr[j])) / arr[j];;
        }
        res += (cur - pre) * i;
        pre = cur;
    }
    return res;
}


int main(int argc, const char *argv[])
{
    int n = 2;
    scanf("%d", &n);
    int *arr = new int [n]{}, MAX = 0;
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &arr[i]);
        if (MAX < arr[i]) { MAX = arr[i]; }
    }
    printf("%.2lf\n", calProb(arr, n, MAX));
    delete []arr;
    return 0;
}
{% endhighlight %}

### 二维表第k大数
<p align="justify">
在一块长为n，宽为m的场地上，有n✖️m个1✖️1的单元格。每个单元格上的数字就是按照从1到n和1到m中的数的乘积。具体如下<br>
n = 3, m = 3<br>
1   2   3<br>
2   4   6<br>
3   6   9<br>
给出一个查询的值k，求出按照这个方式列举的的数中第k大的值v。<br>
例如上面的例子里，<br>
从大到小为(9, 6, 6, 4, 3, 3, 2, 2, 1)<br>
k = 1, v = 9<br>
k = 2, v = 6<br>
k = 3, v = 6<br>
...<br>
k = 8, v = 2<br>
k = 9, v = 1<br><br>

<b>输入描述:</b><br>
只有一行是3个数n, m, k 表示场地的宽高和需要查询的k。使用空格隔开。<br><br>

<b>输出描述:</b><br>
给出第k大的数的值。<br><br>

<b>示例:</b><br>
输入<br>
3 3 4<br>
输出<br>
4<br><br>

<b>备注:</b><br>
【数据范围】<br>
100%的数据<br>
1 <= n, m <= 40000<br>
1 <= k <= n * m<br>
30%的数据<br>
1 <= n, m <= 1000<br><br>

<b>Solution:</b>
</p>
{% highlight C++ %}
#include<iostream>
using namespace std;

long getKthNum(long n, long m, long k)
{
    long left = 1, right = n * m;
    k = n * m - k + 1;
    while (left < right)
    {
        long mid = (left + right) / 2;
        long nRow = mid / m, count = nRow * m;
        for (long i = nRow + 1; i <= n; i++) { count += mid / i; }
        if (count < k) { left = mid + 1; }
        else { right = mid; }
    }
    return left;
}

int main(int argc, const char * argv[])
{
    long n = 3, m = 3, k = 4;
    scanf("%ld%ld%ld", &n, &m, &k);
    printf("%ld\n", getKthNum(n, m, k));
    return 0;
}
{% endhighlight %}

### 
<p align="justify">

<b>输入描述:</b><br>

<b>输出描述:</b><br>

<b>示例:</b><br>

<b>备注:</b><br>

<b>Solution:</b>
</p>
{% highlight C++ %}

{% endhighlight %}