---
layout: post
title:  "面试题"
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


{:toc}

* 
{:toc}


<style>
table {
  border-collapse: collapse;
  border: 1px solid black;
  margin: 0 auto;
} 

th,td {
  border: 1px solid black;
  text-align: center;
}

tr:nth-child(even){background-color: #f2f2f2}

th {
  background-color: #4CAF50;
  color: white;
}

table.a {
  table-layout: auto;
  width: 180px;  
}

table.b {
  table-layout: fixed;
  width: 600px;  
}

table.c {
  table-layout: auto;
  width: 100%;  
}

table.d {
  table-layout: fixed;
  width: 100%;  
}
</style>


## C++
###  new和malloc的区别
<p align="justify">
1、new是操作符，而malloc是函数<br>
2、new在调用的时候先分配内存，在调用构造函数，释放的时候调用析构函数。<br>
3、new是类型安全的，malloc返回void*<br>
4、new可以被重载<br>
5、malloc 可以被realloc<br>
6、new发生错误抛出异常，malloc返回null<br>
7、malloc可以分配任意字节，new 只能分配实例所占内存的整数倍数大小
</p>

## 计算机操作系统
<p align="justify">

</p>

## Python里面有多线程吗？
<p align="justify">
<a href="https://zhuanlan.zhihu.com/p/46368084"> 摘录于此</a><br>
由于GIL的存在，很多人认为Python多进程编程更快，针对多核CPU，理论上来说也是采用多进程更能有效利用资源。<br>
对CPU密集型代码(比如循环计算) - 多进程效率更高<br>
对IO密集型代码(比如文件操作，网络爬虫) - 多线程效率更高。<br>
为什么是这样呢？其实也不难理解。对于IO密集型操作，大部分消耗时间其实是等待时间，在等待时间中CPU是不需要工作的，那你在此期间提供双CPU资源也是利用不上的，相反对于CPU密集型代码，2个CPU干活肯定比一个CPU快很多。那么为什么多线程会对IO密集型代码有用呢？这时因为python碰到等待会释放GIL供新的线程使用，实现了线程间的切换。<br><br>

<a href="https://www.zhihu.com/question/23474039/answer/269526476"> 摘录于此</a><br>
第一种任务的类型是计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力。这种计算密集型任务虽然也可以用多任务完成，但是任务越多，花在任务切换的时间就越多，CPU执行任务的效率就越低，所以，要最高效地利用CPU，计算密集型任务同时进行的数量应当等于CPU的核心数。计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写。<br>
第二种任务的类型是IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）。对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用。IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率。对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差。<br>
综上，Python多线程相当于单核多线程，多线程有两个好处：CPU并行，IO并行，单核多线程相当于自断一臂。所以，在Python中，可以使用多线程，但不要指望能有效利用多核。如果一定要通过多线程利用多核，那只能通过C扩展来实现，不过这样就失去了Python简单易用的特点。不过，也不用过于担心，Python虽然不能利用多线程实现多核任务，但可以通过多进程实现多核任务。多个Python进程有各自独立的GIL锁，互不影响。
</p>

## GBDT与随机森林有什么不同点？
<p align="justify">
DT + Boosting = GBDT<br>
GBDT是一种boosting算法。boosting工作机制：先从初始训练集训练处一个基学习器，然后在根据基学习器的表现对训练样本分布进行调整，使得先前的基学习器做错的训练样本在后续获得更多关注（增加错误样本权重），然后基于调整后的样本分布训练下一个基学习器，如此重复，直到基学习器达到指定的T时，最终将T个基学习器进行加权结合，得出预测。<br>
DT + Bagging = RF<br>
随机森林是bagging的一种扩展，在k个数据集选择的时候后，引入了随机属性选择。加入所有属性个数为d，k是随机选择的属性个数。那么k=d的时候，就没有改变。那么k=1的时候后，随机选择一个属性用于计算。推荐的k=log2d.<br>
随机森林的基学习器一般是决策树算法-主要，也有神经网络。<br>
随机森林是对bagging算法的一点改动，但是根能提现样本集之间的差异性。会提高最终预测结果的泛化能力。<br><br>

GBDT和随机森林的相同点<br>
1、都是由多棵树组成<br>
2、最终的结果都是由多棵树一起决定<br><br>

GBDT和随机森林的不同点<br>
1、组成随机森林的树可以是分类树，也可以是回归树；而GBDT只由回归树组成<br>
2、组成随机森林的树可以并行生成；而GBDT只能是串行生成<br>
3、对于最终的输出结果而言，随机森林采用多数投票等；而GBDT则是将所有结果累加起来，或者加权累加起来<br>
4、随机森林对异常值不敏感，GBDT对异常值非常敏感<br>
5、随机森林对训练集一视同仁，GBDT是基于权值的弱分类器的集成<br>
6、随机森林是通过减少模型方差提高性能，GBDT是通过减少模型偏差提高性能<br><br>

Bagging（套袋法）的算法过程如下：<br>
从原始样本集中使用Bootstraping方法随机抽取n个训练样本，共进行k轮抽取，得到k个训练集。（k个训练集之间相互独立，元素可以有重复）<br>
对于k个训练集，我们训练k个模型（这k个模型可以根据具体问题而定，比如决策树，knn等）<br>
对于分类问题：由投票表决产生分类结果；对于回归问题：由k个模型预测结果的均值作为最后预测结果。（所有模型的重要性相同）<br><br>

Boosting（提升法）的算法过程如下：<br>
对于训练集中的每个样本建立权值wi，表示对每个样本的关注度。当某个样本被误分类的概率很高时，需要加大对该样本的权值。<br>
进行迭代的过程中，每一步迭代都是一个弱分类器。我们需要用某种策略将其组合，作为最终模型。（例如AdaBoost给每个弱分类器一个权值，将其线性组合最为最终分类器。误差越小的弱分类器，权值越大）<br><br>

Bagging，Boosting的主要区别<br>
样本选择上：Bagging采用的是Bootstrap随机有放回抽样；而Boosting每一轮的训练集是不变的，改变的只是每一个样本的权重。<br>
样本权重：Bagging使用的是均匀取样，每个样本权重相等；Boosting根据错误率调整样本权重，错误率越大的样本权重越大。<br>
预测函数：Bagging所有的预测函数的权重相等；Boosting中误差越小的预测函数其权重越大。<br>
并行计算：Bagging各个预测函数可以并行生成；Boosting各个预测函数必须按顺序迭代生成。<br><br>
</p>

## SVM可以做回归问题吗？
<p align="justify">
<a href="https://zhuanlan.zhihu.com/p/33692660"> 摘录于此</a><br>
最简单的线性回归模型是要找出一条曲线使得残差最小。同样的，SVR也是要找出一个超平面，使得所有数据到这个超平面的距离最小。SVR是SVM的一种运用，基本的思路是一致，除了一些细微的区别。使用SVR作回归分析，与SVM一样，我们需要找到一个超平面，不同的是：在SVM中我们要找出一个间隔（gap）最大的超平面，而在SVR，我们定义一个ε，如上图所示，定义虚线内区域的数据点的残差为0，而虚线区域外的数据点（支持向量）到虚线的边界的距离为残差（ζ）。与线性模型类似，我们希望这些残差（ζ）最小。所以大致上来说，SVR就是要找出一个最佳的条状区域（2ε宽度），再对区域外的点进行回归。<br><br>
</p>

## Python里面，为什么要用
{% highlight C++ %}
if __name__ == '__main__'
{% endhighlight %}
<p align="justify">

</p>

## 稳定排序有那些？
<p align="justify">
归并、冒泡、插入、桶排
</p>

## 对输入样本故意添加一些人无法察觉的细微的干扰，这种样本叫什么？
<p align="justify">
对抗样本(Adversarial Examples)
</p>

## 正向最大分词和逆向最大分词
<p align="justify">

</p>

## 平均抛硬币多少次可以得到连续两个正面？
<p align="justify">
三个状态：0个H（初始状态）、1个H、2个H。状态转移方程
$$
\begin{pmatrix}
0.5 & 0.5 & 0\\
0.5 & 0 & 0.5\\
0 & 0 & 1
\end{pmatrix}
$$

设$k_{i}^{A}$从状态i到状态A的平均步数
$$
k_{i}^{A} =
\begin{cases}
0, & \quad i \in A\\
1 + \sum_{j \notin A} P_{ij} k_{j}^{A}, & \quad i \notin A
\end{cases}
$$

$$
\begin{aligned}
& k_{1}^{3} = 1 + P_{11} k_{1}^{3} + P_{12} k_{2}^{3}\\
& k_{2}^{3} = 1 + P_{21} k_{1}^{3} + P_{22} k_{2}^{3}\\
& k_{3}^{3} = 0
\end{aligned}
$$

解得
$$
\begin{aligned}
& k_{1}^{3} = 6\\
& k_{2}^{3} = 4\\
& k_{3}^{3} = 0
\end{aligned}
$$
</p>

## 如何处理正负样本不均匀的情况？
<p align="justify">

</p>

## 推荐系统有哪些常用的评测指标

## 25匹马，5个赛道，每次只能进行一场比赛，求问多少场比赛可以找出前三名。
<p align="justify">
7场<br>
1、将25匹马分成5组，每组进行一场比赛，得到排名，假设排名如下：<br>
A1 > A2 > A3 > A4 > A5<br>
B1 > B2 > B3 > B4 > B5<br>
C1 > C2 > C3 > C4 > C5<br>
D1 > D2 > D3 > D4 > D5<br>
E1 > E2 > E3 > E4 > E5<br>
2、将每组的第一名进行一轮比赛，假设排名如下<br>
A1 > B1 > C1 > D1 > E1<br>
D组和E组可以舍弃，因为D1和E1不能进入前三<br>
有望争夺前三的是A2, A3, B1, B2, C1<br>
3、上述的5匹马进行一轮比赛，得到前两名
</p>

## 考察代码
<p align="justify">
有一个序列1-n，一个机器人从一个起始点b（1 $\leq$ b $\leq$ n）出发，可以向左也可以向右移动一步，但当机器人处于1位置时不能向左，处于n位置时不能向右移动。问当移动k次，刚好落在终点e的路径有几条？<br><br>

例如，输入5 2 3 2<br>
输出 3<br><br>

解释：总共三条路径：<br>
2 -> 1 -> 2 -> 3<br>
2 -> 3 -> 4 -> 3<br>
2 -> 3 -> 2 -> 3<br>
</p>
{% highlight C++ %}
void move(int n, int b, int e, int k, int &count, int &res, int *arr)
{
    if (b <= 0 || b > n) { return; }
    if (count == k)
    {
        if (b == e)
        {
            arr[k] = e;
            for (int i = 0; i < k; i++)
            {
                cout << arr[i] << "->";
            }
            cout << arr[k] << endl;
            res++;
        }
        return;
    }
    arr[count] = b;
    count++;
    move(n, b+1, e, k, count, res, arr);
    move(n, b-1, e, k, count, res, arr);
    count--;
}



int main(int argc, const char * argv[]) {
    // insert code here...
    int n = 5, b = 2, e = 3, k = 5;
    int count = 0, res = 0;
    int *arr = new int[k+1]{};
    move(n, b, e, k, count, res, arr);
    cout << res << endl;
    delete []arr;
    return 0;
}
{% endhighlight %}

<p align="justify">
李白有2斗酒，出门遇到酒店话，酒加倍，遇到莲花话，喝酒一斗。问他遇到5次酒店，10次莲花，且最后一次是莲花，刚好把酒喝完，这样的莲花、酒店组成的序列有多少种？
</p>
{% highlight C++ %}
void move(int f, int h, int nF, int nH, int &count, int res)
{
    //cout << nF << '\t' << nH << endl;
    if (f == nF && h == nH)
    {
        if (res == 1)
        {
            count++;
        }
        return;
    }
    if (nF > f || nH > h || res < 0) { return; }
    move(f, h, nF+1, nH, count, res-1);
    move(f, h, nF, nH+1, count, res*2);
}


int main(int argc, const char * argv[]) {
    // insert code here...
    int f = 9;
    int h = 5;
    int res = 2;
    int count = 0;
    move(f, h, 0, 0, count, res);
    cout << count << endl;
    return 0;
}
{% endhighlight %}

<p align="justify">
有一个文本串T和模式串P，找出T的最短字串S，其中要求S包含P中的所有字符，举例如下：<br>
T = aaabcbdsasfs, P = ab, S = ab<br>
T = aaabcbdsasfs, P = bsf, S = bdsasf
</p>
{% highlight C++ %}
string getSubStr(string T, string P)
{
    int nT = int(T.length()), nP = int(P.length()), N = 256;
    int *ascii = new int [N]{};
    unordered_map<char, int> count;
    unordered_map<char, int>::iterator iter;
    for (int i = 0; i < nP; i++)
    {
        iter = count.find(P[i]);
        if (iter != count.end()) { count[P[i]]++; }
        else { count[P[i]] = 1; }
    }
    int fir = 0, sec = -1;
    for (int i = 0; i < nT; i++)
    {
        iter = count.find(T[i]);
        if (iter != count.end()) { ascii[T[i]]++; }
        bool isBreak = true;
        for (int j = 0; j < nP; j++)
        {
            if (ascii[P[j]] < count[P[j]])
            {
                isBreak = false;
                break;
            }
        }
        if (isBreak)
        {
            sec = i;
            break;
        }
    }
    for (int i = sec; i >= 0; i--)
    {
        if (ascii[T[i]])
        {
            ascii[T[i]]--;
            count[T[i]]--;
        }
        bool isBreak = true;
        for (int j = 0; j < nP; j++)
        {
            if (count[P[j]] > 0)
            {
                isBreak = false;
                break;
            }
        }
        if (isBreak)
        {
            fir = i;
            break;
        }
    }
    printf("fir=%d, sec=%d\n", fir, sec);
    delete []ascii;
    return T.substr(fir, sec-fir+1);
}
{% endhighlight %}

<p align="justify">
石头<br>
题目描述：<br>
沙滩按照线型摆放着n个大小不一的球形石头，已知第i个石头的半径为ri，且不存在两个石头有相同的半径。为了使石头的摆放更加美观，现要求摆放的石头的半径从左往右依次递增。因此，需要对一些石头进行移动，每次操作可以选择一个石头，并把它放在剩下n−1个石头在最左边或最右边。问最少需要操作多少次才能将这n个石头的半径变成升序？<br><br>

输入描述<br>
第一行一个整数n，表示石头的个数。(1 <= n <= 100000) 第二行n个整数，表示从左往右石头的半径r1，r2，...，rn。(1 <= ri <= n)，且保证不存在两个不同的石头拥有相同的半径。<br><br>

输出描述<br>
最少操作次数<br><br>

样例输入<br>
5<br>
4 1 2 5 3<br>
样例输出<br>
2
</p>
{% highlight C++ %}
void stone()
{
    int n = 5, maxLen = 1;
    cin >> n;
    int *arr = new int [n]{};
    for (int i = 0; i < n; i++) { cin >> arr[i]; }
    unordered_map<int, int> dict;
    unordered_map<int, int>::iterator iter;
    for (int i = 0; i < n; i++)
    {
        dict[arr[i]] = 1;
        iter = dict.find(arr[i]-1);
        if (iter != dict.end())
        {
            dict[arr[i]] = dict[arr[i]-1] + 1;
            if (dict[arr[i]] > maxLen) { maxLen = dict[arr[i]]; }
        }
    }
    delete []arr;
    printf("%d\n", n - maxLen);
}
{% endhighlight %}

<p align="justify">
01交替<br>
题目描述：<br>
给你一个长度为n的01串。现在想让你找出最长的01交替子串（子串可以不连续）比如：1010,0101是01交替的串，1101则不是。现在你可以把某一个连续的区间进行翻转，即0变1，1变0。问修改之后的最大01交替子串的长度是多少。<br><br>

输入描述<br>
输入第一行包含一个整数n （1 <= n <= 100000) 表示01串的长度。 第二行包含一个01串。<br><br>

输出描述<br>
输出一个数表示符合题意的子串长度<br><br>

样例输入<br>
8<br>
10000011<br>
样例输出<br>
5
</p>
{% highlight C++ %}
void count01()
{
    int n = 8;
    cin >> n;
    string str = "";
    cin >> str;
    int count = 1;
    for (int i = 0; i < n-1; i++)
    {
        if (str[i] != str[i+1]) { count++; }
    }
    if (count < n-1) { printf("%d\n", count+2); }
    else { printf("%d\n", n); }
}
{% endhighlight %}

<p align="justify">
一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。<br>
测试样例：<br>
[1,2,3],[1,2,3],3,6<br>
返回：6<br><br>

动态规划：dp[i][j]表示前i件物品在最大重量j的条件下的价值
$$
dp[i][j] =\max
\begin{cases}
dp[i-1]][j], &\quad \text{we don't put i-th item in our bag} \\
dp[i-1][j - w[i-1]], &\quad \text{otherwise, but } j > w[i-1], i = 1, 2, ..., N
\end{cases}
$$
</p>
{% highlight C++ %}
inline int MAX(int a, int b) { return a > b ? a : b; }

int knapsack(int v[], int w[], int W, int N)
{
    /*
    v[]: value for each item
    w[]: weight for each item
    W: capacity limit
    N: number of item
    */
    int **dp = new int *[N+1];
    for (int i = 0; i <= N; i++) { dp[i] = new int [W+1]{}; }
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++)
        {
            if (j < w[i-1]) { dp[i][j] = dp[i-1][j]; }
            else { dp[i][j] = MAX(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1]); }
        }
    }
    int res = dp[N][W];
    for (int i = 0; i <= N; i++) { delete []dp[i]; }
    delete []dp;
    return res;
}
{% endhighlight %}