---
layout: page
title:  "动态规划"
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


{:toc}

* 
{:toc}



<style>
table {
  border-collapse: collapse;
  border: 1px solid black;
  margin: 0 auto;
} 

th,td {
  border: 1px solid black;
  text-align: center;
  padding: 20px;
}

table.a {
  table-layout: auto;
  width: 180px;  
}

table.b {
  table-layout: fixed;
  width: 600px;  
}

table.c {
  table-layout: auto;
  width: 100%;  
}

table.d {
  table-layout: fixed;
  width: 100%;  
}
</style>


## 1. 理论基础
<p align="justify">
动态规划（Dynamic programming，简称 DP）将愿问题拆分成若干子问题（子问题有重叠），通过分别求解子问题，得到愿问题解的一种算法。
</p>

### 连续子数组最大和、最大积
#### Leetcode 53. 最大子序和
{% highlight C++ %}
/*
给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），
返回其最大和。

Input: nums = [-2,1,-3,4,-1,2,1,-5,4]
Output: 6
Explanation: [4,-1,2,1] has the largest sum = 6.
*/
int maxSubArray(vector<int>& nums) {
    int n = int(nums.size());
    int maxSum = -(1ll << 31), curSum = 0;
    for (int i = 0; i < n; i++) {
        if (curSum >= 0) { curSum += nums[i]; }
        else { curSum = nums[i]; }
        if (curSum > maxSum) { maxSum = curSum; }
    }
    return maxSum;
}
{% endhighlight %}

#### 最大和的子数组
{% highlight C++ %}
vector<int> getMaxSumEpisode(vector<int> nums)
{
    // vector<int> nums {1, 2, -1, 3};
    int n = int(nums.size());
    vector<int> ans;
    if (n == 0) { return ans; }
    int maxSum = -(1ll << 31), curSum = 0;
    int left = 0, right = 0, begin = 0;
    for (int i = 0; i < n; i++)
    {
        if (curSum >= 0) { curSum += nums[i]; }
        else {
            curSum = nums[i];
            begin = i;
        }
        if (maxSum < curSum) {
            maxSum = curSum;
            left = begin;
            right = i;
        }
    }
    for (int i = left; i <= right; i++) {
        ans.push_back(nums[i]);
    }
    return ans;
}
{% endhighlight %}

#### Leetcode 152. 乘积最大子数组
{% highlight C++ %}
/*
Input: nums = [2,3,-2,4]
Output: 6
Explanation: [2,3] has the largest product 6.
*/
int maxProduct(vector<int>& nums) {
    int n = int(nums.size());
    int minF = nums[0], maxF = nums[0], ans = nums[0];
    for (int i = 1; i < n; i++) {
        int _min = minF, _max = maxF;
        minF = min(nums[i], min(_min * nums[i], _max * nums[i]));
        maxF = max(nums[i], max(_min * nums[i], _max * nums[i]));
        ans = max(ans, maxF);
    }
    return ans;
}
{% endhighlight %}

#### Leetcode 1186. 删除一次得到子数组最大和
{% highlight C++ %}
/*
给你一个整数数组，返回它的某个 非空 子数组（连续元素）在执行一次可选的删除操作后，所能得到
的最大元素总和。

换句话说，你可以从原数组中选出一个子数组，并可以决定要不要从中删除一个元素（只能删一次哦），
（删除后）子数组中至少应当有一个元素，然后该子数组（剩下）的元素总和是所有子数组之中最大的。

注意，删除一个元素后，子数组 不能为空。

请看示例：
示例 1：
输入：arr = [1,-2,0,3]
输出：4
解释：我们可以选出 [1, -2, 0, 3]，然后删掉 -2，这样得到 [1, 0, 3]，和最大。

示例 2：
输入：arr = [1,-2,-2,3]
输出：3
解释：我们直接选出 [3]，这就是最大和。

示例 3：
输入：arr = [-1,-1,-1,-1]
输出：-1
解释：最后得到的子数组不能为空，所以我们不能选择 [-1] 并从中删去 -1 来得到 0。
     我们应该直接选择 [-1]，或者选择 [-1, -1] 再从中删去一个 -1。
*/
class Solution {
public:
    int maximumSum(vector<int>& arr) {
        int n = (int)arr.size();
        if (n == 0) { return 0; }
        const int minEle = *min_element(arr.begin(), arr.end());
        int dp0 = arr[0], dp1 = minEle, ans = dp0;
        for (int i = 1; i < n; i++) {
            int tmp0 = max(dp0 + arr[i], arr[i]);
            int tmp1 = max(dp0, dp1 + arr[i]);
            dp0 = tmp0;
            dp1 = tmp1;
            ans = max(ans, max(dp0, dp1));
        }
        return ans;
    }
};
{% endhighlight %}

#### 最长01等量子串
{% highlight C++ %}
int getLongest01SubstrLen(string str) {
    //str = "0010011001001010110", ans = 16
    int len = 0, n = (int)str.length();
    vector<int> dp(n+1, 0);
    unordered_map<int, int> dict;
    dict[0] = n;
    int pos = n;
    for (int i = n - 1; i >= 0; i--) {
        if (str[i] == '0') {
            dp[i] = dp[i+1] + 1;
        }
        else {
            dp[i] = dp[i+1] - 1;
        }
        if (dict.find(dp[i]) != dict.end()) {
            len = max(len, dict[dp[i]] - i);
            pos = i;
        }
        else {
            dict[dp[i]] = i;
        }
    }
    printf("maxLenSubstr = %s\n", str.substr(pos, len).c_str());
    return len;
}
{% endhighlight %}

### 背包问题
#### 01背包
<p align="justify">
一个背包有一定的承重cap，有N件物品，每件都有自己的价值，记录在数组v中，也都有自己的重量，记录在数组w中，每件物品只能选择要装入背包还是不装入背包，要求在不超过背包承重的前提下，选出物品的总价值最大。给定物品的重量w价值v及物品数n和承重cap。请返回最大总价值。<br>
测试样例：<br>
[1,2,3],[1,2,3],3,6<br>
返回：6<br><br>

动态规划：dp[i][j]表示前i件物品在最大重量j的条件下的价值
$$
dp[i][j] =\max
\begin{cases}
dp[i-1]][j], &\quad \text{we don't put i-th item in our bag} \\
dp[i-1][j - w[i-1]], &\quad \text{otherwise, but } j > w[i-1], i = 1, 2, ..., N
\end{cases}
$$
</p>
{% highlight C++ %}
/* *
 * v[]: value for each item
 * w[]: weight for each item
 * W: capacity limit
 * N: number of item
*/
int knapsack(int v[], int w[], int W, int N) {
    int **dp = new int *[N+1];
    for (int i = 0; i <= N; i++) { dp[i] = new int [W+1]{}; }
    for (int i = 1; i <= N; i++)
    {
        for (int j = 1; j <= W; j++) {
            if (j < w[i-1]) { dp[i][j] = dp[i-1][j]; }
            else {
                dp[i][j] = max(dp[i-1][j], dp[i-1][j-w[i-1]] + v[i-1]);
            }
        }
    }
    int res = dp[N][W];
    for (int i = 0; i <= N; i++) { delete []dp[i]; }
    delete []dp;
    return res;
}
{% endhighlight %}

#### Leetcode 416. 分割等和子集
{% highlight C++ %}
/*
给你一个 只包含正整数 的 非空 数组 nums 。请你判断是否可以将这个数组分割
成两个子集，使得两个子集的元素和相等。

示例 1：
输入：nums = [1,5,11,5]
输出：true
解释：数组可以分割成 [1, 5, 5] 和 [11] 。

示例 2：
输入：nums = [1,2,3,5]
输出：false
解释：数组不能分割成两个元素和相等的子集。
*/
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = (int)nums.size();
        if (n <= 1) { return false; }
        int sum = 0;
        for (int &num : nums) { sum += num; }
        if (sum % 2 == 1) { return false; }
        int target = sum / 2;
        bool *dp = new bool [target+1]{};
        for (int i = 0; i < n; i++) {
            for (int j = target; j >= nums[i]; j--) {
                if (i == 0) { dp[j] = (j == nums[i]); }
                else if (j == 0) { dp[j] = true; }
                else {
                    dp[j] = dp[j] || dp[j-nums[i]];
                }
            }
        }
        bool ans = dp[target];
        delete []dp;
        return ans;
    }
};
{% endhighlight %}

### 正方形
#### Leetcode 221. 最大正方形
{% highlight C++ %}
/*
1 0 1 0 0
1 0 1 1 1
1 1 1 1 1
1 0 0 1 0

输出4
*/
int maximalSquare(vector<vector<char>>& matrix) {
    int nRow = (int)matrix.size();
    if (nRow == 0) { return 0; }
    int nCol = (int)matrix[0].size();
    if (nCol == 0) { return 0; }
    vector<vector<int>> dp(nRow + 1, vector<int> (nCol + 1, 0));
    int ans = 0;
    for (int i = nRow - 1; i >= 0; i--) {
        for (int j = nCol - 1; j >= 0; j--) {
            if (matrix[i][j] == '1') {
                dp[i][j] = min(dp[i+1][j],
                               min(dp[i][j+1], dp[i+1][j+1])) + 1;
            }
            ans = max(ans, dp[i][j] * dp[i][j]);
        }
    }
    return ans;
}
{% endhighlight %}

#### Leetcode 1277. 统计全为 1 的正方形子矩阵
{% highlight C++ %}
/*
0 1 1 1
1 1 1 1
0 1 1 1

输出15
*/
int countSquares(vector<vector<int>>& matrix) {
    int nRow = (int)matrix.size();
    if (nRow == 0) { return 0; }
    int nCol = (int)matrix[0].size();
    if (nCol == 0) { return 0; }
    vector<vector<int>> dp(nRow + 1, vector<int>(nCol + 1, 0));
    int ans = 0;
    for (int i = nRow - 1; i >= 0; i--) {
        for (int j = nCol - 1; j >= 0; j--) {
            if (matrix[i][j]) {
                dp[i][j] = min(dp[i+1][j],
                               min(dp[i][j+1], dp[i+1][j+1])) + 1;
            }
            ans += dp[i][j];
        }
    }
    return ans;
}
{% endhighlight %}

### 编辑距离
#### Leetcode 72. 编辑距离
{% highlight C++ %}
/*
给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。
你可以对一个单词进行如下三种操作：
插入一个字符
删除一个字符
替换一个字符

输入：word1 = "horse", word2 = "ros"
输出：3
解释：
horse -> rorse (将 'h' 替换为 'r')
rorse -> rose (删除 'r')
rose -> ros (删除 'e')
*/
int minDistance(string word1, string word2) {
    string s1 = word1, s2 = word2;
    int n1 = int(s1.length()), n2 = int(s2.length());
    int **dp = new int *[n1+1];
    for (int i = 0; i <= n1; i++) { dp[i] = new int [n2+1]{}; }
    for (int i = 0; i <= n1; i++) {
        for (int j = 0; j <= n2; j++) {
            if (i == 0 || j == 0) { dp[i][j] = max(i, j); }
            else
            {
                int a = dp[i-1][j] + 1;
                int b = dp[i][j-1] + 1;
                int c = dp[i-1][j-1] + (s1[i-1] != s2[j-1]);
                dp[i][j] = min(min(a, b), c);
            }
        }
    }
    int ans = dp[n1][n2];
    for (int i = 0; i <= n1; i++) { delete []dp[i]; }
    delete []dp;
    return ans;
}
{% endhighlight %}

#### 牛客题霸-算法篇 35. 最小编辑代价
{% highlight C++ %}
/*
题目描述
给定两个字符串str1和str2，再给定三个整数ic，dc和rc，分别代表插入、
删除和替换一个字符的代价，请输出将str1编辑成str2的最小代价。
示例1
输入
"abc","adc",5,3,2
返回值
2

示例2
输入
"abc","adc",5,3,100
返回值
8
*/
/**
 * min edit cost
 * @param str1 string字符串 the string
 * @param str2 string字符串 the string
 * @param ic int整型 insert cost
 * @param dc int整型 delete cost
 * @param rc int整型 replace cost
 * @return int整型
 */
int minEditCost(string str1, string str2, int ic, int dc, int rc) {
    // write code here
    int n1 = (int)str1.length(), n2 = (int)str2.length();
    vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));
    for (int i = 0; i <= n1; i++) {
        for (int j = 0; j <= n2; j++) {
            if (i == 0) { dp[i][j] = ic * j; }
            else if (j == 0) { dp[i][j] = dc * i; }
            else {
                int ist = dp[i][j-1] + ic;
                int dlt = dp[i-1][j] + dc;
                int rpl = dp[i-1][j-1] + rc * (str1[i-1] != str2[j-1]);
                dp[i][j] = min(ist, min(dlt, rpl));
            }
        }
    }
    return dp[n1][n2];
}
{% endhighlight %}

### 最长公共子序列
#### Leetcode 1143. 最长公共子序列
{% highlight C++ %}
/*
给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列
的长度。如果不存在 公共子序列 ，返回 0 。

一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变
字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。

例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。
两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。

输入：text1 = "abcde", text2 = "ace" 
输出：3  
解释：最长公共子序列是 "ace" ，它的长度为 3 。
*/
int longestCommonSubsequence(string text1, string text2) {
    string s1 = text1, s2 = text2;
    int n1 = int(s1.length()), n2 = int(s2.length());
    int **dp = new int *[n1+1];
    for (int i = 0; i < n1+1; i++) { dp[i] = new int [n2+1]{}; }
    for (int i = 1; i < n1+1; i++) {
        for (int j = 1; j < n2+1; j++) {
            if (s1[i-1] == s2[j-1]) { dp[i][j] = dp[i-1][j-1] + 1; }
            else {
                dp[i][j] = (dp[i-1][j] > dp[i][j-1] ?
                            dp[i-1][j] : dp[i][j-1]);
            }
        }
    }
    int lcs = dp[n1][n2];
    for (int i = 0; i < n1+1; i++) { delete []dp[i]; }
    delete []dp;
    return lcs;
}
{% endhighlight %}

#### 程序员代码面试指南 31. 最长公共子序列
{% highlight C++ %}
/*
题目描述
给定两个字符串str1和str2，输出连个字符串的最长公共子序列。如过最长公共子序列为空，则输出-1。
输入描述:
输出包括两行，第一行代表字符串str1，第二行代表str2。
输出描述:
输出一行，代表他们最长公共子序列。如果公共子序列的长度为空，则输出-1。
示例1
输入
1A2C3D4B56
B1D23CA45B6A
输出
123456
说明
"123456"和“12C4B6”都是最长公共子序列，任意输出一个。
*/
#include<iostream>
#include<string>
#include<vector>
using namespace std;

string LCS(string s1, string s2) {
    int n1 = (int)s1.length(), n2 = (int)s2.length();
    vector<vector<int>> dp(n1+1, vector<int>(n2+1, 0));
    string ans = "";
    for (int i = n1 - 1; i >= 0; i--) {
        for (int j = n2 - 1; j >= 0; j--) {
            if (s1[i] == s2[j]) { dp[i][j] = dp[i+1][j+1] + 1; }
            else { dp[i][j] = max(dp[i+1][j], dp[i][j+1]); }
        }
    }
    int i = 0, j = 0;
    while (i < n1 && j < n2) {
        if (s1[i] == s2[j]) {
            ans.push_back(s1[i]);
            i++;
            j++;
        }
        else if (dp[i+1][j] > dp[i][j+1]) {
            i++;
        }
        else { j++; }
    }
    return dp[0][0] ? ans : "-1";
}

int main(int argc, const char * argv[]) {
    // insert code here...
    string s1 = "1A2C3D4B56", s2 = "B1D23CA45B6A";
    cin >> s1 >> s2;
    printf("%s\n", LCS(s1, s2).c_str());
    return 0;
}
{% endhighlight %}

### 最长公共子串
#### Leetcode 718. 最长重复子数组
{% highlight C++ %}
/*
给两个整数数组 A 和 B ，返回两个数组中公共的、长度最长的子数组的长度。

Input:
A: [1,2,3,2,1]
B: [3,2,1,4,7]
Output: 3
Explanation: 
The repeated subarray with maximum length is [3, 2, 1].
*/
int findLength(vector<int>& A, vector<int>& B) {
    int na = int(A.size()), nb = int(B.size());
    vector<vector<int>> dp(na+1, vector<int>(nb+1, 0));
    int ans = 0;
    for (int i = 1; i <= na; i++) {
        for (int j = 1; j <= nb; j++) {
            if (A[i-1] == B[j-1]) {
                dp[i][j] = dp[i-1][j-1] + 1;
                ans = max(ans, dp[i][j]);
            }
        }
    }
    return ans;
}
{% endhighlight %}

#### 牛客题霸-算法篇 127. 最长公共子串
{% highlight C++ %}
/*
给定两个字符串str1和str2,输出两个字符串的最长公共子串
题目保证str1和str2的最长公共子串存在且唯一。

示例1
输入
"1AB2345CD","12345EF"
返回值
"2345"
*/
class Solution {
public:
    /**
     * longest common substring
     * @param str1 string字符串 the string
     * @param str2 string字符串 the string
     * @return string字符串
     */
    string LCS(string str1, string str2) {
        // write code here
        int n1 = (int)str1.length(), n2 = (int)str2.length();
        vector<vector<int>> dp(n1+1, vector<int> (n2+1, 0));
        int len = 1, pos = 0;
        for (int i = n1 - 1; i >= 0; i--) {
            for (int j = n2 - 1; j >= 0; j--) {
                if (str1[i] == str2[j]) {
                    dp[i][j] = dp[i+1][j+1] + 1;
                    if (len < dp[i][j]) {
                        len = dp[i][j];
                        pos = i;
                        
                    }
                }
            }
        }
        return str1.substr(pos, len);
    }
};
{% endhighlight %}

### 序列型DP
#### Leetcode 740. 删除并获得点数
{% highlight C++ %}
/*
给你一个整数数组 nums ，你可以对它进行一些操作。

每次操作中，选择任意一个 nums[i] ，删除它并获得 nums[i] 的点数。
之后，你必须删除每个等于 nums[i] - 1 或 nums[i] + 1 的元素。

开始你拥有 0 个点数。返回你能通过这些操作获得的最大点数。

示例 1：
输入：nums = [3,4,2]
输出：6
解释：
删除 4 获得 4 个点数，因此 3 也被删除。
之后，删除 2 获得 2 个点数。总共获得 6 个点数。

示例 2：
输入：nums = [2,2,3,3,3,4]
输出：9
解释：
删除 3 获得 3 个点数，接着要删除两个 2 和 4 。
之后，再次删除 3 获得 3 个点数，再次删除 3 获得 3 个点数。
总共获得 9 个点数。
*/
class Solution {
public:
    int deleteAndEarn(vector<int>& nums) {
        if (nums.empty()) { return 0; }
        map<int, int> cnt;
        for (int num : nums) { cnt[num]++; }
        map<int, int>::iterator iter = ++cnt.begin();
        int lastN = cnt.begin()->first, lastC = cnt.begin()->second;
        int a = 0, b = lastN * lastC;
        for (; iter != cnt.end(); iter++) {
            int na = max(a, b), nb = iter->first * iter->second;
            if (lastN + 1 == iter->first) {
                nb += a;
            }
            else {
                nb += max(a, b);
            }
            a = na;
            b = nb;
            lastN = iter->first;
        }
        return max(a, b);
    }
};
{% endhighlight %}

### 棋盘形DP
#### Leetcode 62. 不同路径
<p align="justify">
$$
\begin{aligned}
& dp[i][1] = 1, \quad i = 1, 2, ..., m \\
& dp[1][j] = 1, \quad j = 1, 2, ..., n \\
& dp[i][j] = dp[i-1][j] + dp[i][j-1], \quad i = 2, 3, ..., m \quad j = 2, 3, ..., n
\end{aligned}
$$
</p>
{% highlight C++ %}
/*
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish” ）。

问总共有多少条不同的路径？

Input: m = 3, n = 2
Output: 3
Explanation:
From the top-left corner, there are a total of 3 ways to reach the
bottom-right corner:
1. Right -> Down -> Down
2. Down -> Down -> Right
3. Down -> Right -> Down
*/
int uniquePaths(int m, int n) {
    int **dp = new int *[m];
    for (int i = 0; i < m; i++) { dp[i] = new int [n]{}; }
    for (int i = 0; i < m; i++) { dp[i][0] = 1; }
    for (int j = 0; j < n; j++) { dp[0][j] = 1; }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = dp[i-1][j] + dp[i][j-1];
        }
    }
    int ans = dp[m-1][n-1];
    for (int i = 0; i < m; i++) { delete []dp[i]; }
    delete []dp;
    return ans;
}
{% endhighlight %}

#### Leetcode 63. 不同路径II
{% highlight C++ %}
/*
一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。

机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。

现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？

Input: obstacleGrid = [[0,0,0],[0,1,0],[0,0,0]]
Output: 2
Explanation: There is one obstacle in the middle of the 3x3 grid above.
There are two ways to reach the bottom-right corner:
1. Right -> Right -> Down -> Down
2. Down -> Down -> Right -> Right
*/
int uniquePathsWithObstacles(vector<vector<int>>& obstacleGrid) {
    vector<vector<int>> mat = obstacleGrid;
    int m = int(mat.size());
    if (m == 0) { return 0; }
    int n = int(mat[0].size());
    if (n == 0) { return 0; }
    int **dp = new int *[m];
    for (int i = 0; i < m; i++) { dp[i] = new int [n]{}; }
    if (mat[0][0]) { return 0; }
    dp[0][0] = 1;
    for (int i = 1; i < m; i++) {
        if (mat[i][0]) { dp[i][0] = 0; }
        else { dp[i][0] = dp[i-1][0]; }
    }
    for (int j = 1; j < n; j++) {
        if (mat[0][j]) { dp[0][j] = 0; }
        else { dp[0][j] = dp[0][j-1]; }
    }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (mat[i][j]) { dp[i][j] = 0; }
            else { dp[i][j] = dp[i-1][j] + dp[i][j-1]; }
        }
    }
    int ans = dp[m-1][n-1];
    for (int i = 0; i < m; i++) { delete []dp[i]; }
    delete []dp;
    return ans;
}
{% endhighlight %}

#### Leetcode 63. 最小路径和
{% highlight C++ %}
/*
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角
到右下角的路径，使得路径上的数字总和为最小。
说明：每次只能向下或者向右移动一步。

1 3 1
1 5 1
4 2 1
Input: grid = [[1,3,1],[1,5,1],[4,2,1]]
Output: 7
Explanation: Because the path 1 → 3 → 1 → 1 → 1 minimizes the sum.
*/
int minPathSum(vector<vector<int>>& grid) {
    int m = int(grid.size());
    if (m == 0) { return 0; }
    int n = int(grid[0].size());
    if (n == 0) { return 0; }
    int **dp = new int *[m];
    for (int i = 0; i < m; i++) { dp[i] = new int [n]{}; }
    dp[0][0] = grid[0][0];
    for (int i = 1; i < m; i++) { dp[i][0] = dp[i-1][0] + grid[i][0]; }
    for (int j = 1; j < n; j++) { dp[0][j] = dp[0][j-1] + grid[0][j]; }
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            dp[i][j] = min(dp[i-1][j], dp[i][j-1]) + grid[i][j];
        }
    }
    int ans = dp[m-1][n-1];
    for (int i = 0; i < m; i++) { delete []dp[i]; }
    delete []dp;
    return ans;
}
{% endhighlight %}

#### 程序员代码面试指南 17. 机器人达到指定位置方法数
{% highlight C++ %}
/*
题目描述
假设有排成一行的N个位置，记为1~N，开始时机器人在M位置，机器人可以往左或者往右走，
如果机器人在1位置，那么下一步机器人只能走到2位置，如果机器人在N位置，那么下一步机
器人只能走到N-1位置。规定机器人只能走k步，最终能来到P位置的方法有多少种。由于方
案数可能比较大，所以答案需要对1e9+7取模。
输入描述:
输出包括一行四个正整数N（2<=N<=5000）、M(1<=M<=N)、K(1<=K<=5000)、P(1<=P<=N)。
输出描述:
输出一个整数，代表最终走到P的方法数对10^9+7取模后的值。
示例1
输入
复制
5 2 3 3
输出
复制
3
说明
1).2->1,1->2,2->3
2).2->3,3->2,2->3
3).2->3,3->4,4->3
*/
#include<iostream>
#include<vector>
using namespace std;

int moveRobot(int N, int M, int K, int P) {
    const int MOD = 1000000007;
    vector<vector<int>> dp(N+2, vector<int>(2, 0));
    dp[M][0] = 1;
    while (K--) {
        for (int i = 1; i <= N; i++) {
            dp[i][1] = (dp[i-1][0] + dp[i+1][0]) % MOD;
        }
        for (int i = 1; i <= N; i++) {
            dp[i][0] = dp[i][1];
        }
    }
    return dp[P][1];
}


int main(int argc, const char *argv[]) {
    int N = 5, M = 2, K = 3, P = 3;
    scanf("%d %d %d %d", &N, &M, &K, &P);
    printf("%d\n", moveRobot(N, M, K, P));
    return 0;
}
{% endhighlight %}

#### Leetcode 1269. 停在原地的方案数
{% highlight C++ %}
/*
有一个长度为 arrLen 的数组，开始有一个指针在索引 0 处。
每一步操作中，你可以将指针向左或向右移动 1 步，或者停在原地
（指针不能被移动到数组范围外）。
给你两个整数 steps 和 arrLen ，请你计算并返回：在恰好执行
steps 次操作以后，指针仍然指向索引 0 处的方案数。
由于答案可能会很大，请返回方案数 模 10^9 + 7 后的结果。

示例 1：
输入：steps = 3, arrLen = 2
输出：4
解释：3 步后，总共有 4 种不同的方法可以停在索引 0 处。
向右，向左，不动
不动，向右，向左
向右，不动，向左
不动，不动，不动

示例  2
输入：steps = 2, arrLen = 4
输出：2
解释：2 步后，总共有 2 种不同的方法可以停在索引 0 处。
向右，向左
不动，不动

示例 3：
输入：steps = 4, arrLen = 2
输出：8
*/
int numWays(int steps, int arrLen) {
    const int MOD = 1000000007;
    int n = min(arrLen, steps / 2 + 1);
    vector<int> dp(n, 0);
    dp[0] = 1;
    while (steps--) {
        vector<int> tmp = dp;
        for (int i = 0; i < n; i++) {
            long a = i == 0 ? 0 : tmp[i - 1];
            long b = i == n - 1 ? 0 : tmp[i + 1];
            long c = tmp[i];
            dp[i] = (a + b + c) % MOD;
        }
    }
    return dp[0];
}
{% endhighlight %}
