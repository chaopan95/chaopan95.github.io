---
layout: page
title:  "排序"
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


{:toc}

* 
{:toc}



<style>
table {
  border-collapse: collapse;
  border: 1px solid black;
  margin: 0 auto;
} 

th,td {
  border: 1px solid black;
  text-align: center;
  padding: 20px;
}

table.a {
  table-layout: auto;
  width: 180px;  
}

table.b {
  table-layout: fixed;
  width: 600px;  
}

table.c {
  table-layout: auto;
  width: 100%;  
}

table.d {
  table-layout: fixed;
  width: 100%;  
}
</style>


## 选择排序
<p align="justify">
Two steps: select + put. That is to say, <br>
(1) at each time, we select a biggest one (or a samllest one), then we put the selected on in our container.<br>
(2) repeat (1)<br><br>

<b>Complexity</b><br>
Both the best condition and the worst condition: $\Theta(n^{2})$<br>
The most time is spent on the first of select, because at each time we have to vist all elements once to find a maximun, then we repeat this step.
$$O(n + (n-1)+...+1)=O(n^{2})$$
</p>

## 冒泡排序（Bubble Sort）
<p align="justify">
(1) Scan all element if two near element form an inversed pair, swap them.<br>
(2) Repeat (1) until all elements are in order.
</p>
{% highlight C++ %}
void BubbleSort(int A[], int n)
{
	for (bool started = false; sorted = !sorted; n--)
	{
		for (int i = 1; i < n; i++)
		{
			if (A[i-1] > A[i])
			{
				swap(A[i-1], A[i]);
				sorted = false;
			}
		}
	}
}
{% endhighlight %}

<p align="justify">
If our array is sorted at some iteration, we can break it.
</p>
{% highlight C++ %}
template <typename T>
void vector<T>::bubbleSort(Rank lo, Rank hi)
{
	while (!bubble(lo, hi--));
}

template <typename T>
bool vector<T>::bubble(Rank lo, Rank hi)
{
	bool sorted = true;
	while (++lo < hi)
	{
		if (_elem[lo-1] > _elem[lo])
		{
			sorted = false;
			swap(_elem[lo-1], _elem[lo]);
		}
	}
	return sorted;
}
{% endhighlight %}

## 归并排序 Merge Sort
<p align="justify">
(1) Divide an array into 2 sub-array recursively until each sub-array has 1 element<br>
(2) Merge 2 ordered arrays
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/mege_sort_1.png"/></center>
</p>
<p align="justify">
$$T(n) = 2T(\frac{n}{2}) + O(n)$$

Complexity is in $O(nlogn)$.
</p>
{% highlight C++ %}
template <typename T>
void vector<T>::mergeSort(Rank lo, Rank hi)
{
	if (hi - lo < 2) return;
	int mi = (lo + hi) >> 1;
	mergeSort(lo, mi);
	mergeSort(mi, hi);
	merge(lo, mi, hi);
}
template <typename T>
void vector<T>::merge(Rank lo, Rank mi, Rank hi)
{
	T *A = _elem + lo;
	int lb = mi - lo;
	T *B = new T[b];
	for (Rank i = 0; i < lb; B[i]=A[i++]);
	int lc = hi - mi;
	T *C = _elem + mi;
	for (Rank i = 0, j = 0, k = 0; (j < lb) || (k < lc); )
	{
		if ((j < lb) && (lc <= k || (B[i] <= C[k]))) A[i++] = B[j++];
		if ((k < lc) && (lb <= j || (C[k] < B[j]))) A[i++] = C[k++];
	}
	delete []B;
}
{% endhighlight %}

## 插入排序Insert Sort
<p align="justify">
We have two containers, one unsorted container an one sorted container. Initially, the sorted container is null.<br>
(1) Pick up one element from the unsorted container (usually we choose the first one)<br>
(2) Insert the selected element into the sorted container by finding its proper position (its value is between its last one and next one)<br>
(3) Repeat (1) and (2)
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/insert_sort1.png"/></center>
</p>
<p align="justify">
Instead of using two container, we can only use one container to implement this algorithm. Precisely, when we enter into the $r^{th}$ position, that is to say, segment [0, r) is well sorted. At this time, we pick up $r^{th}$ element a, we put it into the segment [0, r]. Suppose we find a proper position k to insert a, we have $k \in [0, r]$. So, we put a in the position k and push all elements in [k, r) backward one cell. To implement this algorithm, it is better to take list structure.
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/insert_sort2.png"/></center>
</p>
<p align="justify">
<b>Complexity</b><br>
The best condition: $O(n)$. Because [0, r) is sorted, we only need append a, this take O(n)<br>
The worst condition: $O(n^{2})$. At each time, $r^{th}$ element a will compare each element in [0, r). Here, we use List structure instead of vector, so we must compare one by one.<br><br>

<b>Mean complexity</b><br>
hypothesis: All elements are Independent and identically distributed.<br>
For some iteration r, the time to insert [r] into [0, r] is<br>
$$\frac{r+(r-1)+...+1+0}{r+1}+1=\frac{r}{2}+1$$

So, total expectation is
$$E[\frac{r+(r-1)+...+1+0}{r+1}+1] = E[\frac{r}{2}+1] = E[\frac{0+1+...+n-1}{2}] + 1 = O(n^{2})$$

<b>Input sensitive</b><br>
For one sequence, maximum number of reversed pairs is<br>
$$C_{n}^{2} = \frac{n\cdot (n-1)}{2}$$

For some iteration r, [r] = a. Before r, suppose the number of revsered pari is I, then <br>
$$O(I+n)$$

which denotes I compares and n inserts
</p>

## 桶排序Bucket Sort
<p align="justify">
We apply hash table to sorting. If we know a range of unsorted number, for example, 26 english alphabets. We can etablish a bucket array called count with a length of 26. Besides, we prepare another array called accum with a same size. In advance, we define A to Z by 0 to 25, which corresponds to our bucket array.
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/bucket_sort_1.png"/></center>
</p>
<p align="justify">
We scan an unsorted array, we put each alphabet into our bucket array by counting its appearance time. For example, 'A' for count[0]++. Then we traverse from 0 to 25 to update accum: accum[i] = accum[i-1] + count[i] for i = 1 to 25 and accum[0] = count[0].<br><br>

In order to get a sorted array, we traverse from 0 to 25 again. For example, count['B'] = 1, accum['B'] = 1, represent an interval [0, 1) should be B; count['J'] = 2, accum['J'] = 14, show [12, 14) should be J.<br><br>

Complexity is in $O(n+m)$
</p>

## 堆排序 Heap Sort
<p align="justify">
(1) Heapification for n elements in $O(n)$<br>
(2) Pick root node and delete it in O(logn)<br>
(3) Repeat (2)<br><br>

Time is in $O(n+log(n!)) = O(nlogn)$
$$log(n!) = log(1) + log(2) + \cdots + log(n) \leq log(n) + log(n) + \cdots + log(n) = nlog(n)$$
$$log(n!) \geq log(\frac{n}{2}) + log(\frac{n}{2}+1) + \cdots + log(n) \geq log(\frac{n}{2}) + log(\frac{n}{2}) + \cdots + log(\frac{n}{2}) = \frac{n}{2}log(\frac{n}{2}) $$
</p>

## 快速排序 Quick Sort
<p align="justify">
Divide a sequence S into two sub-sequence
$$S = S_{1} + S_{2}$$

$$max(S_{1}) \leq min(S_{2})$$

If two sub-sequence is sorted, S will be sorted.
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/quick_sort_1.png"/></center>
</p>
{% highlight C++ %}
template <typename T>
void vector<T>::quickOrder(Rank lo, Rank hi)
{
	if (hi - lo < 2) return; // base case
	Rank mi = partition(lo, hi - 1);
	quickSort(lo, mi);
	quickSort(mi+1, hi);
}
{% endhighlight %}
<p align="justify">
Construct a pivot:<br>
(1) Select the first one as candidate for pivot<br>
(2) Prepare two indicator lo, hi pontting to first element and last element<br>
(3) When lo is povot,  if A[hi] < A[lo], swap(A[hi], A[lo]) and set hi as povot, otherwise, hi--; when hi is pivot, if A[lo] > A[hi], swap(A[lo], A[hi]) and set lo as pivot, otherwise, lo++
</p>
{% highlight C++ %}
void quickSort(int *pnt, int start, int end)
{
    int i, j;
    i = start;
    j = end;
    if (start < end)
    {
        while(i < j)
        {
            while(pnt[i] <= pnt[j] && i < j)
            {
                j--;
            }
            swap(pnt, i, j);
            while(pnt[i]<=pnt[j] && i < j)
            {
                i++;
            }
            swap(pnt, i, j);
        }
        quickSort(pnt, start, i-1);
        quickSort(pnt, i+1, end);
    }
}
{% endhighlight %}
<p align="justify">
QuickSort is unstable because it is possible to inverse a left number and a right number. Space is in $O(a)$. Best condition in $O(nlogn)$, worst condition in $O(n^{2})$<br><br>

But average complexity is in $O(nlogn)$
$$T(n) = (n + 1) + \frac{1}{n} = \sum_{k=0}^{n-1}[T(k) + T(n-k-1)] = (n + 1) + \frac{2}{n} \sum_{k=0}^{n-1}T(k)$$

$$nT(n) = n(n+1) + 2\sum_{k=0}^{n-1}T(k)$$

$$(n-1)T(n-1) = (n-1)n + 2\sum_{k=0}^{n-2}T(k)$$

$$nT(n) - (n-1)T(n-1) = 2n + 2T(n-1)$$

$$nT(n) - (n+1)T(n-1) = 2n$$

$$\frac{T(n)}{n+1} = \frac{2}{n+1} + \frac{T(n-1)}{n} = \frac{2}{n+1} + \frac{2}{n} + \frac{T(n-2)}{n-1}$$

$$= \frac{2}{n+1} + \frac{2}{n} + \frac{2}{n-1} + \cdots + \frac{2}{2} + \frac{T(0)}{1}$$

$$= (2ln2)logn = 1.39logn$$

Another version:<br>
We divide a sequence S into 4 parts
$$S = [ lo ] + L(lo, mi] + G(mi, k) + U[k, hi]$$

Similarly, we want to find a pivot
$$L < pivot \leq G$$

If Spivot \leq $[ k ]$, put k into G (k++); otherwise, swap(S[ ++mi ], S[ k++ ]).
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/quick_sort_2.png"/></center>
</p>
{% highlight C++ %}
template <typename T>
Rank vector<T>::partition(Rank lo, Rank hi)
{
	swap(_elem[lo], _elem[lo+rand()%(hi-lo+1)]);
	T pivot = _elem[lo];
	int mi = lo;
	for (int k = lo+1; k <= hi; k++)
	{
		if (_elem[k] < pivot)
		{
			swap(_elem[++mi], _elem[k]);
		}
	}
	swap(_elem[lo], _elem[mi]);
	return mi;
}
{% endhighlight %}
<p align="justify">
The quicksort can adopt different strategies when selecting pivot. This question attempts to use an example to illustrate that the strategy of “choose the middle one of three elements” tends to obtain a more balanced pivot than the randomly selected strategy<br><br>

Let the length of the sequence to be sorted n be large, if the selection of the pivot makes the length ratio of the long/short subsequences after the partition greater than 9:1, it is called unbalanced<br><br>

For different pivot selection strategies, estimate the probability of imbalance<br>
Select one randomly from the n elements as the pivot: 0.2<br>
Select three elements at same probability from n elements with their intermediate elements as pivot:0.056<br><br>

Consider a cube (0, 0, 0) $\rightarrow$ (1, 1, 1). Each axe has three parts a (0, 0.1), b (0, 1, 0.9), c (0.9, 1).<br>
Unbalanced space is 1 - (0.8 * 0.1 * 0.1 * 6+ 0.8 * 0.8 * 0.1 * 6+0.8^3) = 1 - 0.944 = 0.056
</p>
<p align="justify">
<b>Select mode</b><br>
Consider vector A has a prefix P (|P| is even), P has an element x which exactly appears $\frac{|P|}{2}$ in P. If A-P has a mod m, A has a mod m.
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/select_mode_1.png"/></center>
</p>
{% highlight C++ %}
template <typename T> T majEleCandidate (vector<T> A)
{
	T maj;
	for (int c = 0, i = 0; i < A.size(); i++)
	{
		maj = A[i];
		c = 1;
	}
	else
	{
		maj == A[i]?c++:c--;
	}
	return maj;
}
{% endhighlight %}
<p align="justify">
<b>Quick select</b><br>
Consider an unsorted sequence, we can find its povot x, if a target element < x, turn to L; otherwise, turn to G.
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/quick_select_1.png"/></center>
</p>
{% highlight C++ %}
template <typename T>
void quickSelect(vector<T> & A, Rank k)
{
	for (Rank lo = 0, hi = A.szie()-1; lo < hi; )
	{
		Rank i = lo, j = hi;
		T pivot = A[lo];
		while(i < j)
		{
			while(i < j && pivot <= A[j]) j--; A[i] = A[j];
			while(i < j && A[i] <= pivot) i++; A[j] = A[i];
		}
		A[i] = pivot;
		if (k <= i) hi = i - 1;
		if (i <= k) lo = i + 1;
	}
}
{% endhighlight %}
<p align="justify">
<b>Linear select</b><br>
Q is a small constant<br>
(1) if n = |A| < Q return quickSelect(A, k) or others; otherwise, divide A evenly into $\frac{n}{Q}$ sub-sequences with a size of Q<br>
(2) sort each sub-sequence and determine $\frac{n}{Q}$ median<br>
(3) among this medians, call linearSort() to find a median M by recursion<br>
(4) classify all elements according to M: L / E / G = { x < / = / > M | x $\in$ A}<br>
(5)<br>
if k $\leq$ |L|, return linearSelect(L, k)<br>
if k $\leq$ |L| + |E|, return M<br>
return linearSelect(G, k-|L|-|E|)
<center><img src="https://raw.githubusercontent.com/chaopan95/chaopan95.github.io/master/_imgs/DSA/linear_select_1.png"/></center>
</p>
<p align="justify">
Complexity:<br>
$$T(n) = O(n) + T(\frac{n}{Q}) + T(\frac{3n}{4})$$

In order to guarantee linear function
$$\frac{n}{Q} + \frac{3n}{4} < n$$

$$\frac{1}{Q} + \frac{3}{4} < 1$$

Make Q = 5
$$T(n) = cn + T(\frac{n}{5}) + T(\frac{3n}{4}) = O(n)$$
</p>

## 希尔排序Shell Sort
<p align="justify">
Regard a sequence as a matrix, sort each column. Shell sort is also called w-sort.<br> If column w is sorted, we call w-sorted. Diminish w and repeat until w = 0.<br><br>

Insert sort is good for sorting each column.<br><br>

h-ordered: let h $\in$ N, a sequence S[0, n)is h-ordered if S[ i ] $\leq$ S[ i+h ] for 0 $\leq$ i < n-h.<br><br>

A 1-ordered sequence is sorted.<br><br>

h-sorting: an h-ordered sequence is obtained by<br>
(1) arranging S into a 2D matrix with h columns<br>
(2) sorting each column respectively<br><br>

Theorem k -- Knuth<br>
A g-ordered sequence remains g-ordered after being h-sorted.<br><br>

PS, Pratt, Sedgewick
</p>

<details>
  <summary><a href="">排序算法比较 </a></summary>
    <p align="justify">
        <table class="c">
        <tr><th>Sort realm</th><th>Best complexity</th><th>Average complexity</th><th>Worst complexity</th><th>Extra space</th><th>Is stable</th></tr>
        <tr><td>Select Sort</td><td>$O(n^{2})$</td><td>$O(n^{2})$</td><td>$O(n^{2})$</td><td>$O(1)$</td><td>$X$</td></tr>
        <tr><td>Bubble Sort</td><td>$O(n)$</td><td>$O(n^{2})$</td><td>$O(n^{2})$</td><td>$O(1)$</td><td>$\checkmark$</td></tr>
        <tr><td>Merge Sort</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>$\checkmark$</td></tr>
        <tr><td>Insert Sort</td><td>$O(n)$</td><td>$O(n^{2})$</td><td>$O(n^{2})$</td><td>$O(1)$</td><td>$\checkmark$</td></tr>
        <tr><td>Bucket Sort</td><td>$O(n+m)$</td><td>$O(n+m)$</td><td>$O(n+m)$</td><td>$O(n+m)$</td><td>$\checkmark$</td></tr>
        <tr><td>Heap Sort</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n)$</td><td>$X$</td></tr>
        <tr><td>Quick Sort</td><td>$O(nlogn)$</td><td>$O(nlogn)$</td><td>$O(n^{2})$</td><td>$O(1)$</td><td>$X$</td></tr>
        <tr><td>Shell Sort</td><td>$n^{1.5}$</td><td>$n^{1.5}$</td><td>$n^{1.5}$</td><td>$O(1)$</td><td>$X$</td></tr>
        </table>
    </p>
</details>

<details>
  <summary><a href="">Leetcode </a></summary>
  {% highlight C++ %}

  {% endhighlight %}
</details>