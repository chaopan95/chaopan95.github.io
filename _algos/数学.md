---
layout: page
title:  "数学"
---
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    processEscapes: true
  }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>


{:toc}

* 
{:toc}



<style>
table {
  border-collapse: collapse;
  border: 1px solid black;
  margin: 0 auto;
} 

th,td {
  border: 1px solid black;
  text-align: center;
  padding: 20px;
}

table.a {
  table-layout: auto;
  width: 180px;  
}

table.b {
  table-layout: fixed;
  width: 600px;  
}

table.c {
  table-layout: auto;
  width: 100%;  
}

table.d {
  table-layout: fixed;
  width: 100%;  
}
</style>


## 数学
### 最大公约数
#### 两数最大公约数
{% highlight C++ %}
/*
Brutal force: enumerate all numbers from 1 to min(a, b), save the greatest.
*/
int GCD_enumerate(int a, int b)
{
    int c = (a < b ? a : b);
    int gcd = 1;
    for (int i = 1; i <= c; i++)
    {
        if (a % i == 0 && b % i == 0) { gcd = i; }
    }
    return gcd;
}

int GCD_Euclidean_Algorithm_divide(int a, int b)
{
    while (a * b)
    {
        if (a < b) { b %= a; }
        else { a %= b; }
    }
    return (a > b ? a : b );
}

int GCD_Euclidean_Algorithm_subtract(int a, int b)
{
    while (a * b)
    {
        if (a < b) { b -= a; }
        else { a -= b; }
    }
    return (a > b ? a : b);
}
{% endhighlight %}

#### 数组的最大公约数
{% highlight C++ %}
int GCD_Array(vector<int> arr)
{
    int n = int(arr.size());
    if (n == 1) { return arr[0]; }
    int gcd = GCD_Euclidean_Algorithm_divide(arr[0], arr[1]);
    for (int i = 2; i < n; i++)
    {
        gcd = GCD_Euclidean_Algorithm_divide(gcd, arr[i]);
    }
    return gcd;
}
{% endhighlight %}

#### 最大公倍数
<p align="justify">
对于两数a和b的最大公倍数 $\text{LCM} = \frac{a * b}{\text{GCD}(a, b)}$
</p>
{% highlight C++ %}
int LCM(int a, int b) {
    int gcd = GCD_Euclidean_Algorithm_divide(a, b);
    return (a * b) / gcd;
}
{% endhighlight %}

### 位运算符
#### XOR
##### Leetcode 1734. 解码异或后的排列
{% highlight C++ %}
/*
给你一个整数数组 perm ，它是前 n 个正整数的排列，且 n 是个 奇数 。
它被加密成另一个长度为 n - 1 的整数数组 encoded ，满足
encoded[i] = perm[i] XOR perm[i + 1] 。比方说，如果 perm = [1,3,2] ，
那么 encoded = [2,1] 。
给你 encoded 数组，请你返回原始数组 perm 。题目保证答案存在且唯一。

示例 1：
输入：encoded = [3,1]
输出：[1,2,3]
解释：如果 perm = [1,2,3] ，那么 encoded = [1 XOR 2,2 XOR 3] = [3,1]

示例 2：
输入：encoded = [6,5,4,6]
输出：[2,4,1,5,3]
*/
/*
perm包含了1-n+1的所有数字，n为encoded的长度
total = perm[0] ^ ... ^ perm[n-1]
perm[0] ^ perm[1] = encoded[0]
perm[1] ^ perm[2] = encoded[1]
perm[2] ^ perm[3] = encoded[2]
perm[3] ^ perm[4] = encoded[3]
所以，encoded数组中奇数位置的元素XOR，对应了perm1-n的XOR，
由此，可以求得perm[0]的大小
*/
vector<int> decode(vector<int>& encoded) {
    int n = (int)encoded.size();
    vector<int> perm;
    int total = 0;
    for (int i = 1; i <= n+1; i++) { total ^= i; }
    int odd = 0;
    for (int i = 1; i < n; i += 2) { odd ^= encoded[i]; }
    perm.emplace_back(total ^ odd);
    for (int i = 0; i < n; i++) {
        perm.emplace_back(perm.back() ^ encoded[i]);
    }
    return perm;
}
{% endhighlight %}